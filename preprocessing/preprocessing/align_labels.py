#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 14 13:25:04 2020

@author: jnarain
"""

import pandas as pd
from pytz import timezone as timezonepytz
from mutagen.mp3 import MP3
from datetime import datetime, timedelta
from preprocessing_general import *

#This function parses the label data file generated by the labeling app, and stores all the data in the correct format.

#Inputs
#labels_path: path to the .csv file that has the label timing information
#participant_id: the participant whose data is being processed
#data_path: path to the folder containing the audio data being processed
#utc_offset: offset between the recorder clock and UTC time in hours
#drift: calculated drift between the recorder clock and the time server (in s)

#Returns
#id_data: dataframe with all labels for participant_id, with time information stored as datetimes with the correct timezone
def parse_label_csv(labels_path, participant_id, data_path, utc_offset, drift=0):
    labels = pd.read_csv(labels_path)

    #Extract the participant of interest
    id_data = labels.loc[labels['Participant ID'] == participant_id].copy()
    id_data.sort_values(['Participant ID'])
    
    if(id_data.size==0):
        raise SystemExit('There is no label data for the selected participant')

    id_data['Event Created Time']=id_data['Event Created Time'].apply(pd.to_datetime)
    id_data['Event Time']=id_data['Event Time'].apply(pd.to_datetime)
    id_data['Event End']=id_data['Event End'].apply(pd.to_datetime)


    default_duration = 2
    
    id_data['Event Created Time']=(id_data['Event Created Time'].copy()).dt.tz_convert('UTC')
    id_data['Event Time']=(id_data['Event Time'].copy()).dt.tz_convert('UTC')
    id_data['Event End']=(id_data['Event End'].copy()).dt.tz_convert('UTC')

    def fill_na_event_ends(idDF): #data from beginning of study may not have an end time
        if pd.isnull(idDF['Event End']):
            return idDF['Event Time']+timedelta(seconds=default_duration)
        else:
            return idDF['Event End']

    ##Make adjustments for participant anomalies in data set up due to old versions
    id_data['Event End']=id_data.apply(lambda x: fill_na_event_ends(x), axis=1)

    tail = os.path.split(data_path)
    study_date = tail[1]
    folder_date_format = '%Y%m%d'
    utc_offset_seconds = (utc_offset+0.0000001)*3600 + drift #convert utc_offset (given in hours, to seconds)
    
    id_data['Recorder Event Time'] = id_data['Event Created Time'] +timedelta(seconds=utc_offset_seconds)

    id_data_indices = list(id_data.index)
    if len(id_data_indices)==0:
        raise SystemExit('There is no label data for the selected participant')
    
    return id_data

#This function finds the labels that occur within the audio files being processed (in data_path) and calculates the label timings relative to the audio files

#Inputs
#labels_path: path to the .csv file that has the label timing information
#participant_id: the participant whose data is being processed
#data_path: path to the folder containing the audio data being processed
#utc_offset: offset between the recorder clock and UTC time in hours
#drift: calculated drift between the recorder clock and the time server (in s)

#Returns
#internalDF, dfMaster: dataframes that store the calculated timing information for each label

#Outputs
#Saves the calculated timing information as a .csv file with the name "formattedLabels"+part of name of the folder in which the data is being stored.  The .csv file is exported to the data_path folder
def align_data(labels_path, participant_id, data_path, utc_offset, drift = 0):
    pt_data = parse_label_csv(labels_path, participant_id, data_path, utc_offset, drift)

    #Initialize a pandas directory to export as a CSV
    dfMaster = pd.DataFrame()
        
    #Find all the mp3 files in the directory
    files = []
    for filename in os.listdir(data_path):
        if filename.endswith(".mp3"): #The vidoes that have been rotated have the file extension c
            files.append(os.path.join(data_path, filename))

    #The files have numerical names that correspond to the order in which they were recorded
    
    def last_8chars(x):
        return(x[-8:])
        
    files = sorted(files, key = last_8chars)
    internalDF = pd.DataFrame()
    
    for f in files:
        id_data = pt_data
        mod_time=os.path.getmtime(f)
        print(f, ', original time stamp:', datetime.fromtimestamp(mod_time))
        
        audio = MP3(f)
        
        ##Convert the recorder time stamp to UTC, using information in the participant database
        
        utc_offset_seconds = utc_offset*3600+drift #convert utc_offset (given in hours, to seconds)
        seg_start = mod_time - utc_offset_seconds
            
  
        seg_start=datetime.fromtimestamp(seg_start)
        seg_start= seg_start.replace(tzinfo=timezonepytz('UTC'))
        seg_start_time = seg_start       
        print('UTC file start time', seg_start_time)
            
        seg_end_time = seg_start_time+timedelta(seconds=audio.info.length)
        ##seg_start_time and seg_end_time are now in UTC and can be compared to the label dataframe

        #Label Duration will be NaN if it was a custom label (generally a note).  Default to a 2s custom label time
        mask = id_data['Was Custom']
        id_data.loc[mask, 'Event End'] = id_data.loc[mask, 'Event Created Time'] + pd.Timedelta(seconds=2)


        #Get information on the label timing relative to the file
        id_data['Time From Start']=id_data['Event Created Time']-seg_start_time
        id_data['Label Duration']=id_data['Event End']-id_data['Event Created Time']

        id_data['End From File Start'] = id_data['Event End'] - seg_start_time

        #Remove all labels that occurred before the file started; These labels have negative times
        id_data_start = id_data.loc[id_data['Time From Start'] > pd.Timedelta(seconds=0)]
        id_data_end = id_data.loc[id_data['End From File Start'] > pd.Timedelta(seconds=0)]
        id_data = pd.concat([id_data_start, id_data_end]).drop_duplicates()

        #convert to timeobjects
        id_data['Time From Start']=pd.to_timedelta(id_data['Time From Start'])
        id_data['Label Duration']=pd.to_timedelta(id_data['Label Duration'])

        id_data['Time From Start (s)']=id_data['Time From Start'].dt.total_seconds()
        id_data['End From File Start (s)'] = id_data['End From File Start'].dt.total_seconds()


        if (id_data['Time From Start (s)'].size) != 0: #This prevents the code from throwing an error if there are no labels for that audio chunk
            
            #Find those labels that started before the audiofile ends
            audio_data = id_data.loc[id_data['Time From Start (s)']<audio.info.length] #This includes all data with a start time in the audio file
            
            #Find those labels before the audio file but ended during the audio file, or that started during the audio file but ended after rhe audio file
            audio_data2 = id_data[(id_data['Event Created Time'] <= seg_start_time) & ((id_data['Event End'] >= seg_end_time) | ((seg_start_time <= id_data['Event End'])& (seg_end_time >= id_data['Event End']) ))] #This is designed to find labels that encompass an entire file (started before the file began and ends after it ends) or stars before the file began and ends in the file
            audio_data = pd.concat([audio_data, audio_data2], sort=True)

        else: #this will be empty
            audio_data = id_data
        
        audio_data=audio_data.drop_duplicates()

        audio_data['Time From Start (s)']=audio_data['Time From Start'].apply(seconds)
        audio_data['Label Duration (s)']=audio_data['Label Duration'].apply(seconds)

        internalDF = pd.concat([internalDF, audio_data])
                
        startTimes = audio_data['Time From Start'].tolist()
        startTimesSec = [x.total_seconds() for x in startTimes] #convert to a number of seconds; total_seconds preserves negative values #audio_data['Time From Start (s)'].tolist()
        startTimesHms = [hms_string(x, include_sec_frac=True, use_colon=True) for x in startTimesSec]

        labelDuration = audio_data['Label Duration (s)'].tolist()
        givenLabel = audio_data['Label'].tolist()
        
        fname = os.path.basename(f)
        fileList = len(givenLabel)*[fname] #All these entries are from the same file; create a list with the same filename as the number of labels in that file

        data = {'Recorder file':fileList, 'Start relative recorder (s)':startTimesSec, 'Start relative recorder (hh:mm:ss)': startTimesHms, 'Label':givenLabel, 'Label duration':labelDuration}
        df = pd.DataFrame(data)
        dfMaster = pd.concat([dfMaster, df],sort=True)

    csvDest = data_path+"/formattedLabels"+os.path.split(data_path)[1]+".csv"
        
    if os.path.exists(csvDest): #Rewrite file if it already exists
        os.remove(csvDest)
        
    dfMaster.sort_values(['Recorder file', 'Start relative recorder (s)'], ascending=[True, True], inplace=True)
    dfMaster.to_csv(csvDest, index = None, header=True)
    
    return internalDF, dfMaster


